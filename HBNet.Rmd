---
title: "__**PPI humain-microbiote**__"
author: "Elliot Fontaine"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  results = "hide",
  error = FALSE,
  warning = FALSE,
  message = FALSE
)
```

Méthodes basées sur Zhou et al. (2022), <https://doi.org/10.1186/s13059-022-02643-9>

# **0. Initialisation de l'environnement de travail**

Choisir le répertoire de travail. En plus de ce `.Rmd`, il doit contenir le fichier `rest_functions.R`, et les fichiers `BIOGRID-ALL-4.4.221.tab3.txt`, `hpidb_human_list.mitab_plus.txt`, `zhou2022_hbnet.txt` dans un répertoire 'data'.

```{r workspace, eval=FALSE}
setwd("/home/fonell01/github/multilayer-skin")
```

Les modules nécessaires sont les suivants:

```{r dependencies}
# Général
library(tidyverse)
library(readr)

# Web APIs
library(UniProt.ws)
library(httr)
library(jsonlite)
library(biogridr)
# source("rest_functions.R")
```

# **1. Building a putative bacteria‑human protein‑protein interaction (PPI) network**

Il n'y a presque aucun PPI humain-bactérie dans biogrid

```{r biogrid_human}
biogrid <- read_tsv("data/BIOGRID-ALL-4.4.221.tab3.txt") %>%
  dplyr::select(
    "SWISS-PROT Accessions Interactor A",
    "SWISS-PROT Accessions Interactor B",
    "Organism Name Interactor A",
    "Organism Name Interactor B"
  ) %>%
  set_names("A", "B", "Species_A", "Species_B") %>%
  filter(
    (Species_A == "Homo sapiens" & Species_B != "Homo sapiens") |
    (Species_B == "Homo sapiens" & Species_A != "Homo sapiens")
  ) %>%
  filter(A != "-") %>%
  filter(B != "-") %>%
  filter(Species_B != "Mus musculus") %>%
  filter(Species_B != "Rattus norvegicus") %>% 
  filter(Species_B != "Saccharomyces cerevisiae (S288c)")
```

HPIDB

```{r}
hpidb <- read_tsv("data/hpidb_human_list.mitab_plus.txt")
interaction_type <- as.data.frame(table(hpidb$interaction_type))
detection_method <- as.data.frame(table(hpidb$detection_method))
```

Interactions were downloaded from the IntAct database, HPIdb 3.0, and BioGRID [June 2021] and supplemented with additional host-microbe interaction studies, whose interactions were added manually. Only interactions with evidence codes that indicated binary, experimental determination of the interaction between UniProt identifiers with non-matching taxa were preserved, thereby excluding co-complex associations, small molecule interactions, and predicted interactions.

Uniref100/90 clusters containing human proteins and Uniref50 cluster containing bacterial proteins were downloaded from UniProt [June 2021], to which interspecies protein interactors were mapped [89]. PPIs comprising one Uniref100/90 cluster containing human proteins and one Uniref50 cluster containing bacterial proteins were retained for downstream analyses.

Within each UniRef50 bacterial cluster, we further filtered the sequences such that only bacterial members of the cluster within 70% sequence similarity to the experimentally verified protein were labeled as putative interactors. Sequence similarity was calculated using a Smith-Waterman local alignment with the BLOSUM62 matrix via python's parasail [90] library (v.1.1.17) and tallying the number of matches in the pairwise alignment that represent frequent substitutions (non-negative BLOSUM62 scores), divided by the length of the experimentally verified interactor.

-   Formater en MITAB <https://psicquic.github.io/MITAB28Format.html>
-   Filtrer binaire
-   Filtrer experimental
-   Filtrer MIScore
-   Récuperer les IDs uniprots dans la colonne **protein_xref\_`1/2`\_unique**. Il est possible d'aller en chercher dans d'autres colonnes (alternative_identifiers) mais besoin de regex etc, pour l'instant faisons simple.
-   Mapper les IDs uniprots à uniref via le package `UniProt.ws`. Pour savoir si bactérie ou champignon, voir colonne `protein_taxid_2_cat`.

[...]

## Zhou2022 dataset HBNet

Voir **"Additional file 9: Table S8"** de la publication. Contient les IDs UniProt des PPIs interspécifiques, avant tout filtre.

```{r zhou_to_df}
zhou_ppi <- read_tsv("data/zhou2022_hbnet.txt")

# Data Wrangling
zhou_ppi <- zhou_ppi %>%
  mutate(
    interactor_1 = str_extract(Experimental_Interaction, "\\w+"),
    interactor_2 = str_extract(Experimental_Interaction, "(?<=', ')[A-Z0-9]+"),
    publications = str_remove_all(publications, "\\{|\\}|'") # Expressions régulières proposées par chatGPT
  ) %>%
  dplyr::select(interactor_1, interactor_2, db, publications) # On ne garde que les deux premiers IDs d'interacteurs
```

On obtient la liste des protéines uniques dans les interactions, qu'on va chercher à annoter avec les données d'UniProt

```{r zhou_quality_check}
unique_interactors <- data.frame(
  From = unique(c(zhou_ppi$interactor_1, zhou_ppi$interactor_2)),
  stringsAsFactors = FALSE
)

length(unique_interactors$From)
```

On écrit cette liste dans un fichier pour l'importer sur [UniProt](https://www.uniprot.org/id-mapping) pour obtenir les champs supplémentaires qui nous intéressent.

```{r write_to_file}
writeLines(unique_interactors$From, "data/unique_interactors.txt")
```

```{r add_taxonomy}

unique_interactors <- read_tsv("data/idmapping_taxonomy.tsv")

get_taxon <- function(organism_id, lineage) {
  taxon <- NA
  if (!is.na(organism_id) && organism_id == "9606") {
    taxon = "human"
  }
  else if (!is.na(lineage) && grepl("2 (superkingdom)", lineage, fixed = TRUE)) {
    taxon = "bacteria"
  }
  else if (!is.na(lineage) && grepl("10239 (superkingdom)", lineage, fixed = TRUE)) {
    taxon = "virus"
  }
  else if (!is.na(lineage) && grepl("33208 (kingdom)", lineage, fixed = TRUE)) {
    taxon = "metazoa"
  }
  else if (!is.na(lineage) && grepl("4751 (kingdom)", lineage, fixed = TRUE)) {
    taxon = "fungi"
  }
  else if (!is.na(lineage) && grepl("2759 (superkingdom)", lineage, fixed = TRUE)) {
    taxon = "eukaryota"
  }
  else if (!is.na(lineage) && grepl("2157 (superkingdom)", lineage, fixed = TRUE)) {
    taxon = "archaea"
  }
  return(taxon)
}

unique_interactors$taxon <- mapply(
  get_taxon,
  unique_interactors$`Organism (ID)`,
  unique_interactors$`Taxonomic lineage (Ids)`
)

# Pour la suite on utilise Entry plutôt que From, car les UniProt IDs de Entry sont ceux à jour.
writeLines(unique_interactors$Entry, "data/unique_interactors_updated.txt")
```

Sur UniProt, on lance 3 jobs d'ID mapping allant des IDs de `unique_interactors_updated` vers UniRef100, UniRef90 et UniRef50. On filtre les résultats avec le bouton "filter by taxonomy" en haut à gauche pour garder seulement les mapping vers des clusters contenant de l'humain pour UniRef100/90, et contenant bacteria ou contenant fungi pour UniRef50. On exporte au format tsv.

Ce premier filtre ne garde pas que les clusters contenant UNIQUEMENT le taxon d'intérêt, mais il nous simplifie le travail pour le faire. Par exemple pour bacteria, on a seulement à exclure dans R les clusters ayant "root" ou "cellular organisms" en LCA. Pour fongi, on exclut les deux précédents ainsi que "eucaryota" et "opisthokonta". Pour l'humain, on ne garde le cluster que si le LCA est "human".

**Notes:**

-   Certains clusters UniRef100 ne peuvent pas être étendus à Uniref90 ou Uniref50. Peut-être donc que si pour bactérie et champignon on ne map pas sur Uniref50 on devrait tenter de se rabattre sur Uniref90 puis Uniref100 ?

-   Fallait-il vraiment filtrer à "100% du cluster correspond à l'espèce" ? En relisant le papier, ce qu'ils ont fait n'est pas si clair.

```{r add_uniref}
uniref100_human <- read_tsv("data/uniref100_human.tsv")
uniref90_human <- read_tsv("data/uniref90_human.tsv")
uniref50_bacteria <- read_tsv("data/uniref50_bacteria.tsv")
uniref50_fungi <- read_tsv("data/uniref50_fungi.tsv")

# lca_to_remove <- c("root", "cellular organisms", "Eukaryota", "Opisthokonta")
lca_to_remove <- c(1, 131567, 2759, 33154)
uniref100_onlyhuman <- uniref100_human %>% filter(`Common taxon ID` == 9606)
uniref90_onlyhuman <- uniref90_human %>% filter(`Common taxon ID` == 9606)
uniref50_onlybacteria <- uniref50_bacteria %>%
  filter(!(`Common taxon ID` %in% lca_to_remove))
uniref50_onlyfungi <- uniref50_fungi %>%
  filter(!(`Common taxon ID` %in% lca_to_remove))

# Ajouter les clusters à unique_interactors SEULEMENT SI celui-ci ne contient que des bactéries ou que des humains
unique_interactors <- unique_interactors %>%
  mutate(
    homogen_cluster = ifelse(
      taxon == "bacteria" & Entry %in% uniref50_onlybacteria$From,
      uniref50_onlybacteria$`Cluster ID`[match(Entry, uniref50_onlybacteria$From)],
      ifelse(
        taxon == "fungi" & Entry %in% uniref50_onlyfungi$From,
        uniref50_onlyfungi$`Cluster ID`[match(Entry, uniref50_onlyfungi$From)],
        ifelse(
          taxon == "human" & Entry %in% uniref90_onlyhuman$From,
          uniref90_onlyhuman$`Cluster ID`[match(Entry, uniref90_onlyhuman$From)],
          ifelse(
            taxon == "human" & Entry %in% uniref100_onlyhuman$From,
            uniref100_onlyhuman$`Cluster ID`[match(Entry, uniref100_onlyhuman$From)],
            NA_character_
          )
        )
      )
    ),
    identity = as.integer(str_extract(homogen_cluster, "(?<=UniRef)\\d+")) #50, 90, 100
  )
```

On met à jour les IDs UniProt de 2021 (publication) qui ont été "merged" depuis.

```{r merged_id}
zhou_ppi$interactor_1 <- sapply(
  zhou_ppi$interactor_1,
  function(x) {
    with(unique_interactors, Entry[From==x])
  }
)

zhou_ppi$interactor_2 <- sapply(
  zhou_ppi$interactor_2,
  function(x) {
    with(unique_interactors, Entry[From==x])
  }
)
```

Ajoutons les taxons au PPIs de \`zhou_ppi\`, et filtrons les PPI bactérie-humain ou humain-fongi.

```{r human_bacteria_filter}
zhou_ppi$taxon_1 <- sapply(
  zhou_ppi$interactor_1,
  function(x) {
    with(unique_interactors, taxon[Entry==x])[1]
  }
)

zhou_ppi$taxon_2 <- sapply(
  zhou_ppi$interactor_2,
  function(x) {
    with(unique_interactors, taxon[Entry==x])[1]
  }
)

zhou_ppi$ppi_taxons <- paste(zhou_ppi$taxon_1, zhou_ppi$taxon_2, sep=",")

zhou_ppi$cluster_1 <- sapply(
  zhou_ppi$interactor_1,
  function(x) {
    with(unique_interactors, homogen_cluster[Entry==x])
  }
)

zhou_ppi$cluster_2 <- sapply(
  zhou_ppi$interactor_2,
  function(x) {
    with(unique_interactors, homogen_cluster[Entry==x])
  }
)

table(zhou_ppi$ppi_taxons)


skin_ppi <- zhou_ppi %>% 
  filter(!is.na(cluster_1) & !is.na(cluster_2)) %>%
  mutate(to_switch = if_else(taxon_1!='human', TRUE, FALSE))

coupled_columns <- list(
  c("interactor_1", "interactor_2"),
  c("taxon_1", "taxon_2"),
  c("cluster_1", "cluster_2")
)

for (columns in coupled_columns) {
  print(columns)
  skin_ppi[which(skin_ppi$to_switch), columns] <- 
    rev(skin_ppi[which(skin_ppi$to_switch), columns])
}
```

`skin_ppi` contient les PPIs sur lesquelles un mapping est possible. On mappe sur les clusters.

## Données métagénomiques

Alban a donné `data/acne_all_genefamilies.tsv`, qui contient les abondances de protéines (clusters UniRef) pour les cohortes acné et sain issus de Barnard et al. (2016).

```{r barnard_genefamilies}

barnard_genefamilies <- read_tsv("data/acne_all_genefamilies.tsv")

smaller_barnard <- barnard_genefamilies[!grepl("\\|", barnard_genefamilies$`# Gene Family`), ]
smaller_barnard <- smaller_barnard[-1,] # enlever UNMAPPED
smaller_barnard$`# Gene Family` <- substr(
  smaller_barnard$`# Gene Family`,
  start = 10,
  stop = nchar(smaller_barnard$`# Gene Family`)
) # enlever "UniRef90_"

frac_size <- 100000
n_files <- nrow(smaller_barnard) %/% frac_size + 1

for (i in 1:n_files) {
  low_bound <- (i - 1) * frac_size + 1
  up_bound <- min(i*frac_size, nrow(smaller_barnard))
  frac_barnard <- smaller_barnard$`# Gene Family`[low_bound:up_bound]
  writeLines(frac_barnard, paste0("data/barnard_ref90_2019_", i, ".txt"))
}


```

On mappe sur UniProt **(UniProtKB_AC-ID → UniRef50)**. Malheureusement, énormément d'IDs ne mappent pas. Il va peut-être falloir utiliser UniRef de 2019 pour être cohérent avec Humann3.

```{r barnard_uniref50_mapped}

barnard_uniref50_2023 <- rbind(
  read_tsv("data/barnard_ref50_2023_1.tsv"),
  read_tsv("data/barnard_ref50_2023_2.tsv"),
  read_tsv("data/barnard_ref50_2023_3.tsv"),
  read_tsv("data/barnard_ref50_2023_4.tsv"),
  read_tsv("data/barnard_ref50_2023_5.tsv"),
  read_tsv("data/barnard_ref50_2023_6.tsv")
)
colnames(barnard_uniref50_2023) <- c("# Gene Family", "Cluster ID")

print(
  paste(
    "Pourcentage de mapping réussi:",
    100 * nrow(barnard_uniref50_2023) / nrow(smaller_barnard)
  )
)
```

On veut ensuite calculer les "expositions" des protéines humaines en sommant les abondances des intéracteurs bactériens de cette protéine, au sein du sample.

```{r human_prots_exposition}

# skin_ppi
# barnard_uniref50_2023
# smaller_barnard


smaller_barnard <- left_join(smaller_barnard, barnard_uniref50_2023, by = "# Gene Family") %>%
  relocate("# Gene Family","Cluster ID")

human_prot_exposition <- data.frame(
  stringsAsFactors = FALSE,
  matrix(
    ncol = length(colnames(smaller_barnard)) - 1,
    nrow = length(unique(skin_ppi$cluster_1))
  )
)

colnames(human_prot_exposition) <- c("uniref100", colnames(smaller_barnard)[-c(1:2)])

human_prot_exposition$uniref100 <- unique(skin_ppi$cluster_1)

for (sample in colnames(human_prot_exposition)[-1]) {
  print(sample)
}
  
```

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

OLD

Attribuons les espèces aux ids

```{r add_taxonomy}
up <- UniProt.ws(taxId=9606)
res <- select(
  up,
  keys = unique_interactors,
  keytype = "UniProtKB",
  columns = c("organism_name", "organism_id")
)
# Environ 1 minute

```

Mapper sur uniref

```{r uniref90_mapping}
interactors_ref90 <- mapUniProt(
    from = "UniProtKB_AC-ID",
    to = 'UniRef90',
    # columns = c("id"),
    query = unique_interactors
)
```

Certains IDs UniProt (18 au total) ne semblent pas matcher via `mapUniProt`, il faut aller les chercher manuellement.

```{r uniref90_unmapped}
unmapped <- character()
for(i in 1:nrow(interactors_ref90)) {
  if (interactors_ref90$From[i] == "Error encountered when streaming data. Please try again later.") {
    unmapped <- append(unmapped, unique_interactors[i])
  }
}
print(unmapped)
```

mapUniProt( from = "UniParc", to = "UniProtKB", \# columns = c("id"), query = c("E9PKA7") )
